<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stargazing</title>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-61M5LTFQB7"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-61M5LTFQB7');
    </script>
    <script src="https://unpkg.com/astronomy-engine@latest/astronomy.browser.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #0f172a;
            /* Dark blue/slate background */
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            text-align: center;
            padding: 1rem;
        }

        .container {
            padding: 2rem;
            background: #1e293b;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            width: 100%;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: #38bdf8;
            /* Light blue */
        }

        h2 {
            font-size: 1.2rem;
            color: #94a3b8;
            margin-top: 2rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #334155;
            padding-bottom: 0.5rem;
        }

        .time-box {
            background: #334155;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
        }

        .time-label {
            font-size: 0.875rem;
            color: #94a3b8;
            margin-bottom: 0.25rem;
        }

        .time-value {
            font-size: 1.5rem;
            font-weight: bold;
            font-variant-numeric: tabular-nums;
        }

        .data-section {
            margin-top: 1.5rem;
            border-top: 1px solid #334155;
            padding-top: 1.5rem;
        }

        .btn {
            background: #38bdf8;
            color: #0f172a;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #0ea5e9;
        }

        .hidden {
            display: none;
        }

        .solar-event {
            display: flex;
            justify-content: space-between;
            margin: 0.5rem 0;
            font-size: 1.1rem;
        }

        .solar-label {
            color: #94a3b8;
        }

        #error-msg {
            color: #ef4444;
            margin-top: 1rem;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Stargazing</h1>

        <div class="time-box">
            <div class="time-label">Current UTC Time</div>
            <div id="utc-time" class="time-value">Loading...</div>
            <div class="time-label" style="margin-top: 1rem;">Local System Time</div>
            <div id="local-time" class="time-value">Loading...</div>
        </div>

        <div id="initial-state">
            <p style="margin-bottom: 1.5rem; color: #cbd5e1;">Detecting location...</p>
            <button id="locate-btn" class="btn">Use Precise Location</button>
        </div>

        <div id="loading-state" class="hidden">
            <p>Scanning the cosmos...</p>
        </div>

        <div id="data-state" class="hidden data-section">
            <div style="margin-bottom: 1rem; font-size: 0.9rem; color: #94a3b8;">
                Coordinates: <span id="location-coords"></span>
            </div>
            <div id="location-name-container"
                style="margin-bottom: 1rem; font-size: 1.1rem; color: #38bdf8; font-weight: 500;">
                <span id="location-name"></span>
            </div>

            <div class="solar-event">
                <span class="solar-label">üåÖ Sunrise</span>
                <span id="sunrise-time">--:--</span>
            </div>
            <div class="solar-event">
                <span class="solar-label">üåá Sunset</span>
                <span id="sunset-time">--:--</span>
            </div>
            <div class="solar-event">
                <span class="solar-label">üåô Moon Phase</span>
                <span id="moon-phase">--</span>
            </div>
            <div class="solar-event">
                <span class="solar-label">üåë Next New Moon</span>
                <span id="next-new-moon">--</span>
            </div>
            <div class="solar-event">
                <span class="solar-label">üåö Last New Moon</span>
                <span id="last-new-moon">--</span>
            </div>
            <div class="solar-event">
                <span class="solar-label">üåï Next Full Moon</span>
                <span id="next-full-moon">--</span>
            </div>
            <div class="solar-event">
                <span class="solar-label">üåù Last Full Moon</span>
                <span id="last-full-moon">--</span>
            </div>
        </div>

        <div id="error-msg" class="hidden"></div>

        <div class="external-links"
            style="margin-top: 2rem; border-top: 1px solid #334155; padding-top: 1rem; font-size: 0.9rem;">
            <div id="skymap-container"
                style="width: 100%; height: 350px; border-radius: 8px; overflow: hidden; margin-top: 1rem;">
                <!-- VirtualSky iframe will be injected here -->
            </div>
            Powered by <a href="https://lco.global/spacebook/sky-map/" target="_blank" style="color: #64748b;">LCO
                VirtualSky</a>
        </div>
        <div style="margin-top: 1rem; border-top: 1px dotted #334155; padding-top: 0.5rem;">
            <a id="ha-link" href="#" target="_blank"
                style="color: #38bdf8; text-decoration: none; border-bottom: 1px dotted #38bdf8;">View Sky Chart on
                Heavens-Above</a>
        </div>
    </div>
    </div>

    <script>
        // Update clock every second
        function updateClock() {
            const now = new Date();

            // Helper to format as: Fri, 02 Jan 26
            const formatTime = (date, isUTC) => {
                const pad = (n) => n.toString().padStart(2, '0');

                // Day of week
                const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                const dayName = isUTC ? days[date.getUTCDay()] : days[date.getDay()];

                // Month names (3-letter)
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const monthName = isUTC ? months[date.getUTCMonth()] : months[date.getMonth()];

                const year = isUTC ? date.getUTCFullYear().toString().slice(-2) : date.getFullYear().toString().slice(-2);
                const day = pad(isUTC ? date.getUTCDate() : date.getDate());

                const hours = pad(isUTC ? date.getUTCHours() : date.getHours());
                const minutes = pad(isUTC ? date.getUTCMinutes() : date.getMinutes());
                const seconds = pad(isUTC ? date.getUTCSeconds() : date.getSeconds());

                return `${dayName}, ${day} ${monthName} ${year} ${hours}:${minutes}:${seconds}`;
            };

            document.getElementById('utc-time').innerText = formatTime(now, true) + ' UTC';

            // Get local timezone abbreviation if possible
            let tzName = '';
            try {
                // Try to get short timezone name (e.g. PST, IST, EST)
                tzName = new Date().toLocaleTimeString('en-us', { timeZoneName: 'short' }).split(' ').pop();
                // If it's something like "GMT+5:30", we keep it. 
                // Sometimes it might return just "PM" if split fails or format is different, so let's be careful.
                const parts = new Intl.DateTimeFormat('en-US', { timeZoneName: 'short' }).formatToParts(now);
                const tzPart = parts.find(p => p.type === 'timeZoneName');
                if (tzPart) tzName = tzPart.value;
            } catch (e) {
                tzName = 'Local';
            }

            document.getElementById('local-time').innerText = formatTime(now, false) + ' ' + tzName;
        }
        setInterval(updateClock, 1000);
        updateClock();

        const locateBtn = document.getElementById('locate-btn');
        const initialState = document.getElementById('initial-state');
        const loadingState = document.getElementById('loading-state');
        const dataState = document.getElementById('data-state');
        const errorMsg = document.getElementById('error-msg');

        // Auto-detect location on load
        window.addEventListener('load', () => {
            fetchIPLocation();
        });

        locateBtn.addEventListener('click', () => {
            if (!navigator.geolocation) {
                showError("Geolocation is not supported by your browser.");
                return;
            }

            initialState.classList.add('hidden');
            loadingState.classList.remove('hidden');
            dataState.classList.add('hidden'); // Hide data while re-fetching

            getLoc(true);
        });

        async function fetchIPLocation() {
            try {
                const response = await fetch('https://ipapi.co/json/');
                const data = await response.json();

                if (data.latitude && data.longitude) {
                    success({
                        coords: {
                            latitude: data.latitude,
                            longitude: data.longitude
                        }
                    }, false); // Pass false to indicate this is not precise location
                } else {
                    throw new Error("Invalid IP data");
                }
            } catch (e) {
                console.warn("IP Location failed:", e);
                // Don't show error to user, just stay on initial state waiting for manual click
            }
        }

        function getLoc(highAccuracy) {
            navigator.geolocation.getCurrentPosition(
                (pos) => success(pos, true),
                (err) => {
                    if (highAccuracy) {
                        console.log("High accuracy failed, retrying with low accuracy...");
                        getLoc(false);
                    } else {
                        error(err);
                    }
                },
                {
                    enableHighAccuracy: highAccuracy,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }

        function success(position, isPrecise) {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;

            document.getElementById('location-coords').innerText =
                `${lat.toFixed(4)}, ${lng.toFixed(4)}` + (isPrecise ? " (GPS)" : " (IP)");

            fetchSolarData(lat, lng);
            fetchLocationName(lat, lng);

            const now = new Date();

            if (typeof Astronomy !== 'undefined') {
                updateMoonDetails(now);
            } else {
                console.warn("Astronomy library not loaded yet. Retrying in 500ms...");
                setTimeout(() => {
                    if (typeof Astronomy !== 'undefined') {
                        updateMoonDetails(now);
                    } else {
                        console.error("Astronomy library failed to load.");
                        document.getElementById('moon-phase').innerText = "Lib Error";
                    }
                }, 500);
            }

            // Update UI
            initialState.classList.add('hidden');
            loadingState.classList.add('hidden');
            dataState.classList.remove('hidden');

            updateExternalLinks(lat, lng);
        }

        function updateExternalLinks(lat, lng) {
            const container = document.getElementById('skymap-container');
            // Clean up existing iframes
            container.innerHTML = '';

            const iframe = document.createElement('iframe');
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.border = 'none';

            // Build VirtualSky URL
            // Docs: https://lco.global/virtualsky/
            const baseUrl = "https://virtualsky.lco.global/embed/index.html";
            const params = new URLSearchParams({
                longitude: lng,
                latitude: lat,
                projection: 'stereo',
                constellations: 'true',
                constellationlabels: 'true',
                showstarlabels: 'true',
                showplanets: 'true',
                showplanetlabels: 'true',
                showdate: 'false', // We show date elsewhere
                showposition: 'false',
                live: 'true', // Auto update time
                az: 180, // Facing South by default
                background: 'rgba(0,0,0,0)', // Transparent to blend with our dark theme? Or just dark.
                // Actually transparent might be hard to read on some backgrounds, lets use a dark hex
                // VirtualSky background param takes css color.
                // Our card is #1e293b. Lets match it or go slightly darker.
                color: 'white',
            });

            iframe.src = `${baseUrl}?${params.toString()}`;
            container.appendChild(iframe);

            // Update Heavens-Above Link as well
            const haLink = document.getElementById('ha-link');
            // Calculate Heavens-Above timezone parameter
            // Format: UCT[m]H[colonM]
            const offset = new Date().getTimezoneOffset();

            let tzParam = 'UCT';
            if (offset !== 0) {
                if (offset < 0) tzParam += 'm';
                const absOffset = Math.abs(offset);
                const hours = Math.floor(absOffset / 60);
                const mins = absOffset % 60;
                tzParam += hours;
                if (mins > 0) tzParam += 'colon' + mins;
            }

            const haUrl = `https://heavens-above.com/main.aspx?lat=${lat}&lng=${lng}&loc=Unnamed&alt=0&tz=${tzParam}`;
            haLink.href = haUrl;
            haLink.innerText = `View Sky Chart on Heavens-Above (Lat: ${lat.toFixed(2)}, Lng: ${lng.toFixed(2)})`;
        }

        function error(err) {
            console.warn(`ERROR(${err.code}): ${err.message}. Falling back to default location.`);
            // Fallback to New Delhi
            success({
                coords: {
                    latitude: 28.6139,
                    longitude: 77.2090
                }
            });
        }

        function showError(msg) {
            errorMsg.innerText = msg;
            errorMsg.classList.remove('hidden');
        }

        async function fetchLocationName(lat, lng) {
            const nameEl = document.getElementById('location-name');
            nameEl.innerText = "Locating city...";

            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=10&addressdetails=1`);
                const data = await response.json();

                if (data && data.address) {
                    const city = data.address.city || data.address.town || data.address.village || data.address.hamlet || data.address.county;
                    const country = data.address.country;
                    nameEl.innerText = city ? `${city}, ${country}` : data.display_name.split(',')[0];
                } else {
                    nameEl.innerText = "Unknown Location";
                }
            } catch (e) {
                console.error("Reverse geocoding failed", e);
                nameEl.innerText = "";
            }
        }

        async function fetchSolarData(lat, lng) {
            try {
                const response = await fetch(`https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lng}&formatted=0`);
                const data = await response.json();

                if (data.status === 'OK') {
                    const sunrise = new Date(data.results.sunrise);
                    const sunset = new Date(data.results.sunset);

                    const now = new Date();

                    const timeStr = (date) => date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                    document.getElementById('sunrise-time').innerText =
                        `${timeStr(sunrise)} (${getRelativeTime(sunrise)})`;

                    document.getElementById('sunset-time').innerText =
                        `${timeStr(sunset)} (${getRelativeTime(sunset)})`;

                    loadingState.classList.add('hidden');
                    dataState.classList.remove('hidden');
                } else {
                    throw new Error('API Error');
                }
            } catch (err) {
                loadingState.classList.add('hidden');
                initialState.classList.remove('hidden');
                showError("Failed to fetch solar data. Please try again.");
                console.error(err);
            }
        }

        function updateMoonDetails(date) {
            // Current Phase
            const phase = Astronomy.MoonPhase(date); // 0..360
            const phaseName = getMoonPhaseName(phase);
            document.getElementById('moon-phase').innerText = phaseName;

            const updateElement = (id, eventDate) => {
                const el = document.getElementById(id);
                if (el && eventDate) {
                    const params = { weekday: 'short', year: '2-digit', month: 'short', day: 'numeric' };
                    const dateStr = eventDate.toLocaleDateString(undefined, params);
                    el.innerText = `${dateStr} (${getRelativeTime(eventDate)})`;
                }
            };

            // Helpers to find moon phases
            // Next New Moon (Phase 0)
            const nextNew = Astronomy.SearchMoonPhase(0, date, 30);
            if (nextNew) updateElement('next-new-moon', nextNew.date);

            // Last New Moon (Phase 0) - Search starting from 35 days ago to find the one just before now
            const pastDate = new Date(date.getTime() - 35 * 24 * 60 * 60 * 1000);
            const lastNew = Astronomy.SearchMoonPhase(0, pastDate, 30); // Should find the one ~5 day ago or ~30 days ago
            // We want to ensure it is indeed in the past. If search found one in future relative to now (unlikely if we started 35 days ago), ignore.
            // Actually simpler: Search 2 phases starting 60 days ago, pick the last one < now.
            // But 'SearchMoonPhase' finds the *first* occurrence after date.
            // So logic: Start -40 days. Find occurrence. 
            // If occurrence < now, that is a candidate. 
            // Search again from occurrence + 1 minute.
            // Keep strictly < now.
            {
                // Robust "Last" finder
                let d = new Date(date.getTime() - 45 * 24 * 60 * 60 * 1000); // 45 days ago
                let found = null;
                for (let i = 0; i < 3; i++) {
                    const m = Astronomy.SearchMoonPhase(0, d, 45);
                    if (m && m.date < date) {
                        found = m.date;
                        d = new Date(m.date.getTime() + 1000); // Advance slightly
                    } else {
                        break;
                    }
                }
                if (found) updateElement('last-new-moon', found);
            }


            // Next Full Moon (Phase 180)
            const nextFull = Astronomy.SearchMoonPhase(180, date, 30);
            if (nextFull) updateElement('next-full-moon', nextFull.date);

            // Last Full Moon
            {
                let d = new Date(date.getTime() - 45 * 24 * 60 * 60 * 1000);
                let found = null;
                for (let i = 0; i < 3; i++) {
                    const m = Astronomy.SearchMoonPhase(180, d, 45);
                    if (m && m.date < date) {
                        found = m.date;
                        d = new Date(m.date.getTime() + 1000);
                    } else {
                        break;
                    }
                }
                if (found) updateElement('last-full-moon', found);
            }
        }

        function getRelativeTime(targetDate) {
            const now = new Date();
            const diffMs = targetDate - now;
            const diffSec = Math.floor(diffMs / 1000);
            const absSec = Math.abs(diffSec);

            const isFuture = diffSec > 0;
            const prefix = isFuture ? 'in ' : '';
            const suffix = isFuture ? '' : ' ago';

            if (absSec < 60) return "now";
            if (absSec < 3600) {
                const mins = Math.floor(absSec / 60);
                return `${prefix}${mins}m${suffix}`;
            }
            if (absSec < 86400) {
                const hours = Math.floor(absSec / 3600);
                const mins = Math.floor((absSec % 3600) / 60);
                // e.g. "2h 30m ago"
                return `${prefix}${hours}h ${mins}m${suffix}`;
            }
            // Days
            const days = Math.floor(absSec / 86400);
            const hours = Math.floor((absSec % 86400) / 3600);
            return `${prefix}${days}d ${hours}h${suffix}`;
        }

        function getMoonPhaseName(degrees) {
            if (degrees < 10 || degrees > 350) return "New Moon üåë";
            if (degrees < 80) return "Waxing Crescent üåí";
            if (degrees < 100) return "First Quarter üåì";
            if (degrees < 170) return "Waxing Gibbous üåî";
            if (degrees < 190) return "Full Moon üåï";
            if (degrees < 260) return "Waning Gibbous üåñ";
            if (degrees < 280) return "Last Quarter üåó";
            return "Waning Crescent üåò";
        }



    </script>
</body>

</html>